{"ast":null,"code":"'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar crypto = require('crypto');\n\nvar utils = require('./utils');\n\nvar Error = require('./Error');\n\nvar Webhook = {\n  DEFAULT_TOLERANCE: 300,\n  // 5 minutes\n  constructEvent: function (payload, header, secret, tolerance) {\n    this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE);\n    var jsonPayload = JSON.parse(payload);\n    return jsonPayload;\n  },\n\n  /**\n   * Generates a header to be used for webhook mocking\n   *\n   * @typedef {object} opts\n   * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n   * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n   * @property {string} secret - Stripe webhook secret 'whsec_...'\n   * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n   * @property {string} signature - Computed webhook signature\n   */\n  generateTestHeaderString: function (opts) {\n    if (!opts) {\n      throw new Error.StripeError({\n        message: 'Options are required'\n      });\n    }\n\n    opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n    opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n    opts.signature = opts.signature || signature._computeSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n    var generatedHeader = ['t=' + opts.timestamp, opts.scheme + '=' + opts.signature].join(',');\n    return generatedHeader;\n  }\n};\nvar signature = {\n  EXPECTED_SCHEME: 'v1',\n  _computeSignature: function (payload, secret) {\n    return crypto.createHmac('sha256', secret).update(payload, 'utf8').digest('hex');\n  },\n  verifyHeader: function (payload, header, secret, tolerance) {\n    payload = Buffer.isBuffer(payload) ? payload.toString('utf8') : payload;\n    header = Buffer.isBuffer(header) ? header.toString('utf8') : header;\n    var details = parseHeader(header, this.EXPECTED_SCHEME);\n\n    if (!details || details.timestamp === -1) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'Unable to extract timestamp and signatures from header',\n        detail: {\n          header: header,\n          payload: payload\n        }\n      });\n    }\n\n    if (!details.signatures.length) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'No signatures found with expected scheme',\n        detail: {\n          header: header,\n          payload: payload\n        }\n      });\n    }\n\n    var expectedSignature = this._computeSignature(details.timestamp + '.' + payload, secret);\n\n    var signatureFound = !!details.signatures.filter(utils.secureCompare.bind(utils, expectedSignature)).length;\n\n    if (!signatureFound) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'No signatures found matching the expected signature for payload.' + ' Are you passing the raw request body you received from Stripe?' + ' https://github.com/stripe/stripe-node#webhook-signing',\n        detail: {\n          header: header,\n          payload: payload\n        }\n      });\n    }\n\n    var timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n\n    if (tolerance > 0 && timestampAge > tolerance) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'Timestamp outside the tolerance zone',\n        detail: {\n          header: header,\n          payload: payload\n        }\n      });\n    }\n\n    return true;\n  }\n};\n\nfunction parseHeader(header, scheme) {\n  if (typeof header !== 'string') {\n    return null;\n  }\n\n  return header.split(',').reduce(function (accum, item) {\n    var kv = item.split('=');\n\n    if (kv[0] === 't') {\n      accum.timestamp = kv[1];\n    }\n\n    if (kv[0] === scheme) {\n      accum.signatures.push(kv[1]);\n    }\n\n    return accum;\n  }, {\n    timestamp: -1,\n    signatures: []\n  });\n}\n\nWebhook.signature = signature;\nmodule.exports = Webhook;","map":{"version":3,"sources":["C:/Developing/portfolios/bnb_clone/node_modules/stripe/lib/Webhooks.js"],"names":["Buffer","require","crypto","utils","Error","Webhook","DEFAULT_TOLERANCE","constructEvent","payload","header","secret","tolerance","signature","verifyHeader","jsonPayload","JSON","parse","generateTestHeaderString","opts","StripeError","message","timestamp","Math","floor","Date","now","scheme","EXPECTED_SCHEME","_computeSignature","generatedHeader","join","createHmac","update","digest","isBuffer","toString","details","parseHeader","StripeSignatureVerificationError","detail","signatures","length","expectedSignature","signatureFound","filter","secureCompare","bind","timestampAge","split","reduce","accum","item","kv","push","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar crypto = require('crypto');\n\nvar utils = require('./utils');\nvar Error = require('./Error');\n\nvar Webhook = {\n  DEFAULT_TOLERANCE: 300, // 5 minutes\n\n  constructEvent: function(payload, header, secret, tolerance) {\n    this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE);\n\n    var jsonPayload = JSON.parse(payload);\n    return jsonPayload;\n  },\n\n  /**\n   * Generates a header to be used for webhook mocking\n   *\n   * @typedef {object} opts\n   * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n   * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n   * @property {string} secret - Stripe webhook secret 'whsec_...'\n   * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n   * @property {string} signature - Computed webhook signature\n   */\n  generateTestHeaderString: function(opts) {\n    if (!opts) {\n      throw new Error.StripeError({\n        message: 'Options are required',\n      });\n    }\n\n    opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n    opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n\n    opts.signature = opts.signature ||\n      signature._computeSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n\n    var generatedHeader = [\n      't=' + opts.timestamp,\n      opts.scheme + '=' + opts.signature,\n    ].join(',');\n\n    return generatedHeader;\n  },\n};\n\nvar signature = {\n  EXPECTED_SCHEME: 'v1',\n\n  _computeSignature: function(payload, secret) {\n    return crypto.createHmac('sha256', secret)\n      .update(payload, 'utf8')\n      .digest('hex');\n  },\n\n  verifyHeader: function(payload, header, secret, tolerance) {\n    payload = Buffer.isBuffer(payload) ? payload.toString('utf8') : payload;\n    header = Buffer.isBuffer(header) ? header.toString('utf8') : header;\n\n    var details = parseHeader(header, this.EXPECTED_SCHEME);\n\n    if (!details || details.timestamp === -1) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'Unable to extract timestamp and signatures from header',\n        detail: {\n          header: header,\n          payload: payload,\n        },\n      });\n    }\n\n    if (!details.signatures.length) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'No signatures found with expected scheme',\n        detail: {\n          header: header,\n          payload: payload,\n        },\n      });\n    }\n\n    var expectedSignature = this._computeSignature(details.timestamp + '.' + payload, secret);\n\n    var signatureFound = !!details.signatures\n      .filter(utils.secureCompare.bind(utils, expectedSignature))\n      .length;\n\n    if (!signatureFound) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'No signatures found matching the expected signature for payload.' +\n          ' Are you passing the raw request body you received from Stripe?' +\n          ' https://github.com/stripe/stripe-node#webhook-signing',\n        detail: {\n          header: header,\n          payload: payload,\n        },\n      });\n    }\n\n    var timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n\n    if (tolerance > 0 && timestampAge > tolerance) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'Timestamp outside the tolerance zone',\n        detail: {\n          header: header,\n          payload: payload,\n        },\n      });\n    }\n\n    return true;\n  },\n};\n\nfunction parseHeader(header, scheme) {\n  if (typeof header !== 'string') {\n    return null;\n  }\n\n  return header.split(',').reduce(function(accum, item) {\n    var kv = item.split('=');\n\n    if (kv[0] === 't') {\n      accum.timestamp = kv[1];\n    }\n\n    if (kv[0] === scheme) {\n      accum.signatures.push(kv[1]);\n    }\n\n    return accum;\n  }, {\n    timestamp: -1,\n    signatures: [],\n  });\n}\n\nWebhook.signature = signature;\n\nmodule.exports = Webhook;\n"]},"metadata":{},"sourceType":"script"}