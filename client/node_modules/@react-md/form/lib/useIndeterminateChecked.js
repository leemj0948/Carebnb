"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useIndeterminateChecked = void 0;
var react_1 = require("react");
/**
 * This hook allows you to toggle the state of multiple checkboxes in a single
 * place along with an indeterminate checkbox that can check/uncheck all
 * checkboxes at once.
 *
 * @example
 * Simple value list with labels lookup:
 * ```tsx
 * const values = ["a", "b", "c", "d"] as const;
 * const LABELS = {
 *   a: "Label 1",
 *   b: "Label 2",
 *   c: "Label 3",
 *   d: "Label 4",
 * } as const;
 * const { getProps, rootProps } = useIndeterminateChecked(values);
 *
 * return (
 *   <>
 *     <Checkbox id="root-checkbox" {...rootProps} label="Root Checkbox" />
 *     {values.map((value, i) => (
 *       <Checkbox
 *         id={`child-checkbox-${i + 1}`}
 *         label={LABELS[value]}
 *         {...getProps(value)}
 *       />
 *     ))}
 *   </>
 * );
 * ```
 *
 * @example
 * Fetch Data From Server and check first result
 * ```tsx
 * interface ServerFetchedData {
 *   id: Guid;
 *   name: string;
 * }
 *
 *
 * const [data, setData] = useState<ServerFetchedData[]>([]);
 * const { getProps, rootProps, setCheckedValues } = useIndeterminateChecked(
 *   data.map(({ id }) => id),
 * );
 *
 * useEffect(() => {
 *   let cancelled = false;
 *   (async function load() {
 *     const response = await fetch("/my-api");
 *     const json = await response.json();
 *     if (!cancelled) {
 *       // pretend validation and sanity checks
 *       setData(json as ServerFetchedData[]);
 *       setCheckedValues(json[0].id);
 *     }
 *   })();

 *   return () => {
 *     cancelled = true;
 *   };
 * }, []);
 *
 * return (
 *   <>
 *     <Checkbox id="root-checkbox" {...rootProps} label="Root Checkbox" />
 *     {data.map(({ id, name }, i) => (
 *       <Checkbox
 *         id={`child-checkbox-${i + 1}`}
 *         label={name}
 *         {...getProps(id)}
 *       />
 *     ))}
 *   </>
 * );
 * ```
 *
 * @example
 * With MenuItemCheckbox
 * ```tsx
 * const values = ["a", "b", "c", "d"] as const;
 * const LABELS = {
 *   a: "Label 1",
 *   b: "Label 2",
 *   c: "Label 3",
 *   d: "Label 4",
 * } as const;
 * const { getProps, rootProps } = useIndeterminateChecked(values, {
 *   menu: true,
 * });
 *
 * return (
 *   <DropdownMenu
 *     id="dropdown-menu-id"
 *     items={[
 *       <MenuItemCheckbox
 *         id="dropdown-menu-id-toggle-all"
 *         {...rootProps}
 *       >
 *         Toggle All
 *       </MenuItemCheckbox>,
 *       ...values.map((value, i) => (
 *         <MenuItemCheckbox
 *           id={`dropdown-menu-id-${i + 1}`}
 *           {...getProps(value)}
 *         >
 *           {LABELS[value]}
 *         </MenuItemCheckbox>
 *       ))
 *     ]}
 *   >
 *     Button
 *   </DropdownMenu>
 * );
 * ```
 *
 * @typeParam V - The allowed values for the checkboxes
 * @param values - The allowed values for the checkboxes which is used to
 * control the checked states.
 * @param defaultOrOptions - The {@link IndeterminateCheckedHookOptions} or a
 * `useState` initializer callback/default value for backwards compatibility
 * @param optionalOnChange - This is really just for backwards compatibility and
 * should not be used. Use {@link IndeterminateCheckedHookOptions.onChange}
 * instead.
 * @returns an object containing the `rootProps` to pass to the indeterminate
 * checkbox, a `getProps` function to provide the controlled behavior for the
 * additional `values` in the checkbox list, a list of `checkedValues`, and a
 * `setCheckedValues` function to manually override the state if needed.
 */
function useIndeterminateChecked(values, defaultOrOptions, optionalOnChange) {
    var _a, _b, _c, _d;
    var menu = false;
    var propOnChange = optionalOnChange;
    var defaultCheckedValues;
    if (typeof defaultOrOptions === "undefined" ||
        !("length" in defaultOrOptions)) {
        (_a = defaultOrOptions !== null && defaultOrOptions !== void 0 ? defaultOrOptions : {}, _b = _a.menu, menu = _b === void 0 ? false : _b, propOnChange = _a.onChange, _c = _a.defaultCheckedValues, defaultCheckedValues = _c === void 0 ? [] : _c);
    }
    else {
        defaultCheckedValues = defaultOrOptions;
    }
    var _e = react_1.useState(defaultCheckedValues), checkedValues = _e[0], setCheckedValues = _e[1];
    var checked = checkedValues.length > 0;
    var indeterminate = checked && checkedValues.length < values.length;
    var updateCheckedValues = function (values) {
        propOnChange === null || propOnChange === void 0 ? void 0 : propOnChange(values);
        setCheckedValues(values);
    };
    var rootProps = (_d = {
            "aria-checked": indeterminate ? "mixed" : undefined,
            checked: checked,
            indeterminate: indeterminate
        },
        _d[menu ? "onCheckedChange" : "onChange"] = function () {
            updateCheckedValues(checkedValues.length === 0 || indeterminate ? values : []);
        },
        _d);
    var getProps = function (value) {
        var _a;
        return _a = {
                value: value,
                checked: checkedValues.includes(value)
            },
            _a[menu ? "onCheckedChange" : "onChange"] = function () {
                var i = checkedValues.indexOf(value);
                var nextChecked = checkedValues.slice();
                if (i === -1) {
                    nextChecked.push(value);
                }
                else {
                    nextChecked.splice(i, 1);
                }
                updateCheckedValues(nextChecked);
            },
            _a;
    };
    return {
        rootProps: rootProps,
        getProps: getProps,
        checkedValues: checkedValues,
        setCheckedValues: setCheckedValues,
    };
}
exports.useIndeterminateChecked = useIndeterminateChecked;
//# sourceMappingURL=useIndeterminateChecked.js.map